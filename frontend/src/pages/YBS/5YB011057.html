<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive YBS Machine Circuit Board Layout - Assembly Verification</title>
    <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js"></script>
    <style>
        :root {
            --left-pcb-color: #b5e6b5;
            --master-pcb-color: #d3d3d3;
            --right-pcb-color: #a8e4f0;
            --highlight-yellow: #ffeb3b;
            --board-to-board-color: #999;
            --board-to-board-green: #5c9e31;
            --border-color: #aaa;
            --hover-shadow: 0 0 10px rgba(0, 123, 255, 0.3);
            --transition-speed: 0.2s;
            --bg-color-body: #f8f8f8;
            --bg-color-container: #fff;
            --text-color-dark: #333;
            --text-color-light: #f1f5f9;
            --header-border-color: #ddd;
            --component-name-bg: #e9ecef;
            --component-name-text: var(--text-color-dark);
            --tooltip-bg: rgba(54, 69, 79, 0.95);
            --tooltip-text: var(--text-color-light);
            --status-success: #4ade80;
            --status-error: #f87171;
            --status-pending: #cbd5e1;
            --progress-bg: #e2e8f0;
            --progress-fill: #3b82f6;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 1.5rem;
            background-color: var(--bg-color-body);
            color: var(--text-color-dark);
            line-height: 1.5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--bg-color-container);
            border-radius: 0.5rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            padding: 2rem;
            position: relative;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
            position: relative;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--header-border-color);
        }

        .title {
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--text-color-dark);
            margin-bottom: 0.75rem;
            text-shadow: 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .part-id {
            position: absolute;
            left: 0;
            top: 0;
            background-color: #f97316;
            color: var(--text-color-light);
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-weight: 600;
            font-size: 0.875rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .board-to-board-title {
            color: #38bdf8;
            font-size: 2rem;
            font-weight: 700;
            text-align: center;
            margin: 1.5rem 0;
            text-shadow: 0 0 5px rgba(56, 189, 248, 0.4);
            position: relative;
        }

        .board-to-board-title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            height: 3px;
            background: linear-gradient(90deg, transparent, #38bdf8, transparent);
        }

        .circuit-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            border: 1.5px solid var(--border-color);
            border-radius: 0.375rem;
            overflow: hidden;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            position: relative;
            z-index: 10;
            background-color: #fff;
        }

        .circuit-table td {
            border: 1px solid var(--border-color);
            padding: 0.5rem 0.25rem;
            font-size: 0.75rem;
            height: 2.5rem;
            position: relative;
            transition: all var(--transition-speed) ease;
        }

        .component-name {
            text-align: left;
            font-weight: 700;
            padding-left: 1rem;
            background-color: var(--component-name-bg);
            color: var(--component-name-text);
            width: 8rem;
            vertical-align: middle;
            position: relative;
            overflow: hidden;
        }

        .component-name::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 10px;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0,0,0,0.05));
        }

        .cell {
            position: relative;
            overflow: hidden;
            transition: all var(--transition-speed) ease;
        }

        .cell:hover {
            transform: scale(1.05);
            box-shadow: var(--hover-shadow);
            z-index: 100;
        }

        .sensor-cell {
            width: 1.75rem;
            font-size: 0.875rem;
            font-weight: 600;
            background-color: #fff9e6;
            vertical-align: middle;
            cursor: pointer;
            text-align: center;
        }

        .sensor-cell.success {
            background-color: var(--status-success);
            color: white;
        }

        .sensor-cell.error {
            background-color: var(--status-error);
            color: white;
        }

        .sensor-cell.next {
            background-color: var(--highlight-yellow);
            animation: pulse 2s infinite;
        }

        .highlighted-sensor {
            background-color: var(--highlight-yellow);
            font-weight: 700;
            color: #333;
            position: relative;
            overflow: hidden;
        }

        .highlighted-sensor::after {
            content: '';
            position: absolute;
            bottom: 0;
            right: 0;
            width: 0.5rem;
            height: 0.5rem;
            background: linear-gradient(135deg, transparent 50%, rgba(0,0,0,0.1) 50%);
        }

        .left-pcb {
            background-color: var(--left-pcb-color);
            text-align: center;
            font-size: 0.7rem;
            font-weight: 500;
            padding: 0.75rem 0.25rem;
            line-height: 1.3;
            vertical-align: middle;
            position: relative;
            cursor: pointer;
        }

        .left-pcb::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, rgba(0,0,0,0.05), rgba(0,0,0,0.1), rgba(0,0,0,0.05));
        }

        .master-pcb {
            background-color: var(--master-pcb-color);
            color: var(--text-color-dark);
            text-align: center;
            font-size: 0.7rem;
            font-weight: 500;
            padding: 0.75rem 0.25rem;
            line-height: 1.3;
            vertical-align: middle;
            position: relative;
            cursor: pointer;
        }

        .master-pcb::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, rgba(0,0,0,0.05), rgba(0,0,0,0.1), rgba(0,0,0,0.05));
        }

        .right-pcb {
            background-color: var(--right-pcb-color);
            text-align: center;
            font-size: 0.7rem;
            font-weight: 500;
            padding: 0.75rem 0.25rem;
            line-height: 1.3;
            vertical-align: middle;
            position: relative;
            cursor: pointer;
        }

        .right-pcb::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, rgba(0,0,0,0.05), rgba(0,0,0,0.1), rgba(0,0,0,0.05));
        }

        .board-to-board {
            background-color: var(--board-to-board-color);
            color: var(--text-color-light);
            text-align: center;
            font-size: 0.7rem;
            font-weight: 500;
            line-height: 1.2;
            vertical-align: middle;
            background-image: linear-gradient(to bottom, rgba(0,0,0,0.05), transparent);
            cursor: pointer;
        }

        .board-to-board-green {
            background-color: var(--board-to-board-green);
            color: var(--text-color-light);
            text-align: center;
            font-size: 0.7rem;
            font-weight: 500;
            line-height: 1.2;
            vertical-align: middle;
            background-image: linear-gradient(to bottom, rgba(0,0,0,0.05), transparent);
            cursor: pointer;
        }

        .power-cable {
            background-color: #ffffff;
            text-align: center;
            font-weight: 600;
            font-size: 0.875rem;
            padding: 0.75rem 0.25rem;
            vertical-align: middle;
            background-image: linear-gradient(to bottom, #f9f9f9, #ffffff);
            cursor: pointer;
        }

        .empty-cell {
            background-color: #ffffff;
        }

        .circuit-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .circuit-lines::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                radial-gradient(circle at 10% 10%, rgba(59, 130, 246, 0.03) 1px, transparent 1px),
                radial-gradient(circle at 20% 50%, rgba(59, 130, 246, 0.03) 1px, transparent 1px),
                radial-gradient(circle at 30% 30%, rgba(59, 130, 246, 0.03) 1px, transparent 1px),
                radial-gradient(circle at 40% 70%, rgba(59, 130, 246, 0.03) 1px, transparent 1px),
                radial-gradient(circle at 50% 40%, rgba(59, 130, 246, 0.03) 1px, transparent 1px);
            background-size: 100px 100px;
        }

        .glow {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% 50%, rgba(56, 189, 248, 0.05), transparent 70%);
            pointer-events: none;
            z-index: 1;
        }

        .tooltip {
            position: absolute;
            background: var(--tooltip-bg);
            color: var(--tooltip-text);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 200px;
            z-index: 1000;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            transform: translateY(10px);
            opacity: 0;
            pointer-events: none;
            transition: all 0.2s ease;
        }

        .tooltip.show {
            opacity: 1;
            transform: translateY(0);
        }

        .tooltip::after {
            content: '';
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 0 6px 6px;
            border-style: solid;
            border-color: transparent transparent var(--tooltip-bg);
        }

        .connection-line {
            position: absolute;
            background: rgba(56, 189, 248, 0.4);
            height: 2px;
            z-index: 15;
            transform-origin: left;
            transform: scaleX(0);
            pointer-events: none;
        }

        .connection-line.active {
            transform: scaleX(1);
            box-shadow: 0 0 8px rgba(56, 189, 248, 0.6);
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.5); }
            70% { box-shadow: 0 0 0 8px rgba(255, 235, 59, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 235, 59, 0); }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        .scan-section {
            margin-top: 2rem;
            padding: 1.5rem;
            background-color: #f1f5f9;
            border-radius: 0.5rem;
            border: 1px solid #cbd5e1;
        }

        .scan-input-container {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .scan-input {
            flex: 1;
            padding: 0.75rem 1rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.375rem;
            font-size: 1rem;
        }

        .scan-button {
            padding: 0.75rem 1.5rem;
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 0.375rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .scan-button:hover {
            background-color: #2563eb;
        }

        .scan-button:disabled {
            background-color: #94a3b8;
            cursor: not-allowed;
        }

        .progress-container {
            margin: 1.5rem 0;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .progress-label {
            font-weight: 600;
            color: #475569;
        }

        .progress-percentage {
            font-weight: 600;
            color: #3b82f6;
        }

        .progress-bar {
            height: 0.5rem;
            background-color: var(--progress-bg);
            border-radius: 9999px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background-color: var(--progress-fill);
            border-radius: 9999px;
            transition: width 0.3s ease;
        }

        .logs-container {
            margin-top: 1.5rem;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 0.375rem;
            background-color: white;
        }

        .log-header {
            padding: 0.75rem 1rem;
            background-color: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
            font-weight: 600;
            color: #475569;
        }

        .log-entry {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-time {
            color: #64748b;
            font-size: 0.875rem;
        }

        .log-message {
            flex: 1;
            margin-left: 1rem;
        }

        .log-entry.success .log-message {
            color: #16a34a;
        }

        .log-entry.error .log-message {
            color: #dc2626;
        }

        .log-entry.info .log-message {
            color: #2563eb;
        }

        .notification {
            position: fixed;
            top: 1rem;
            right: 1rem;
            padding: 1rem;
            border-radius: 0.375rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            color: white;
            font-weight: 500;
            z-index: 1000;
            max-width: 24rem;
            opacity: 0;
            transform: translateY(-1rem);
            transition: opacity 0.3s, transform 0.3s;
        }

        .notification.show {
            opacity: 1;
            transform: translateY(0);
        }

        .notification.success {
            background-color: #16a34a;
        }

        .notification.error {
            background-color: #dc2626;
        }

        .notification.info {
            background-color: #2563eb;
        }

        @media (max-width: 992px) {
            .container {
                padding: 1rem;
            }

            .component-name {
                width: 6rem;
                font-size: 0.7rem;
            }

            .sensor-cell {
                width: 1.5rem;
                font-size: 0.75rem;
                padding: 0.25rem 0.125rem;
            }

            .left-pcb, .master-pcb, .right-pcb {
                font-size: 0.65rem;
                padding: 0.5rem 0.125rem;
            }

            .power-cable {
                font-size: 0.75rem;
            }

            .scan-input-container {
                flex-direction: column;
            }
        }

        @media (max-width: 768px) {
            .title {
                font-size: 1.5rem;
            }

            .board-to-board-title {
                font-size: 1.75rem;
            }

            .circuit-table {
                font-size: 0.65rem;
            }

            .component-name {
                width: 5rem;
            }
        }

        .complete-button {
            margin-top: 1.5rem;
            padding: 0.75rem 1.5rem;
            background-color: #16a34a;
            color: white;
            border: none;
            border-radius: 0.375rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
        }

        .complete-button:hover {
            background-color: #15803d;
        }

        .complete-button:disabled {
            background-color: #94a3b8;
            cursor: not-allowed;
        }

        .hidden {
            display: none;
        }

        .restart-button {
            margin-top: 1rem;
            padding: 0.75rem 1.5rem;
            background-color: #f97316;
            color: white;
            border: none;
            border-radius: 0.375rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
        }

        .restart-button:hover {
            background-color: #ea580c;
        }

        .scan-controls {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        .scan-controls button {
            flex: 1;
        }

        .retry-button {
            padding: 0.75rem 1.5rem;
            background-color: #6b7280;
            color: white;
            border: none;
            border-radius: 0.375rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .retry-button:hover {
            background-color: #4b5563;
        }
        
        .notification-error {
            background-color: #ef4444;
            color: white;
            padding: 1rem;
            border-radius: 0.375rem;
            margin-bottom: 1rem;
            display: none;
        }
    </style>
    <script>
        let currentWorkOrderDetails = null; // To store fetched work order details

        document.addEventListener('DOMContentLoaded', function() {
            // Existing sensor barcode mapping code
            const sensorBarcodes = {
                1: "R22J200177",
                2: "R22J102367",
                3: "R22J102368",
                4: "R22J102440",
                5: "R22J102371",
                6: "R22J102389",
                7: "R22J102390",
                8: "R22J102391",
                9: "R22J102392",
                10: "R22J102393",
                11: "R22J102394",
                12: "R22J102395",
                13: "R22J102396",
                14: "R22J102397",
                15: "R22J102398",
                16: "R22J102399",
                17: "R22J102400",
                18: "R22J102401",
                19: "R22J102402",
                20: "R22J102403",
                21: "R22J102404",
                22: "R22J102405",
                23: "R22J102406",
                24: "R22J102407"
            };
            
            // Component item codes based on user-provided values
            const componentItemCodes = {
                "left_pcb": "4YB013250",    // Left Slave PCB
                "master_pcb": "4YB013248",  // Master PCB
                "right_pcb": "4YB013251",   // Right Slave PCB
                "b2b_left_master": "4YB013258", // B2B (left-master)
                "b2b_master_right": "4YB013258", // B2B (master-right)
                "pc_cable": "4YB013255"     // Power & Communication Cable
            };
            
            // Sensor item codes based on user-provided values
            const sensorItemCodes = {
                1: "5YB013255",  // Special sensor code
                16: "5YB013255", // Special sensor code
                24: "5YB013255"  // Special sensor code
            };
            
            // Default item code for sensors 2-15 and 17-23
            const defaultSensorItemCode = "5YB013254";

            // API endpoint for inventory data
            const API_URL = '/api';
            
            // Storage for codes fetched from API
            const componentCodeMap = {};
            let sensorCodeMap = {};
            let apiInitialized = false;

            // Initialize variables
            let currentSensorIndex = 1;
            let scannedSensors = [];
            let assemblyId = null; // Store the assembly ID
            // Get elements
            const barcodeInput = document.getElementById('barcodeInput');
            const scanButton = document.getElementById('scanButton');
            const completeButton = document.getElementById('completeButton');
            const progressFill = document.getElementById('progressFill');
            const progressPercentage = document.getElementById('progressPercentage');
            const logsContent = document.getElementById('logsContent');
            const sensorCells = {};
            const errorMessage = document.getElementById('errorMessage');
            
            // Initialize sensor cells
            document.querySelectorAll('.sensor-cell').forEach(cell => {
                const sensorId = parseInt(cell.getAttribute('data-sensor-id'));
                sensorCells[sensorId] = cell;
                
                // Set initial tooltip
                cell.setAttribute('data-tooltip', `Sensor #${sensorId}: ${sensorBarcodes[sensorId]}`);
            });
            
            // Function to show API failure message
            function showApiFailureMessage() {
                errorMessage.style.display = 'block';
                errorMessage.innerHTML = `
                    <div style="text-align: center; padding: 1rem;">
                        <h3 style="color: #dc2626; margin-bottom: 0.5rem;">API Connection Failed</h3>
                        <p style="color: #475569; font-size: 0.9rem; margin-bottom: 0.5rem;">Error: Failed to retrieve verification codes from API</p>
                        <p style="color: #475569; font-size: 0.9rem; margin-bottom: 0.5rem;">Component IDs:</p>
                        <ul style="color: #475569; font-size: 0.9rem; margin-left: 1.5rem; margin-bottom: 1rem;">
                            ${Object.entries(componentItemCodes).map(([key, code]) => `<li>${key}: ${code}</li>`).join('')}
                        </ul>
                        <p style="color: #475569; font-size: 0.9rem;">Please provide this information to IT support.</p>
                    </div>
                    <button onclick="window.location.reload()"
                            style="margin-top: 2rem; background: #3b82f6; color: white; padding: 0.75rem 1.5rem; 
                                   border: none; border-radius: 0.375rem; cursor: pointer;">
                        Try Again
                    </button>
                `;
                
                apiInitialized = false;
            }
            
            // Function to initialize the API and fetch verification codes
            async function initializeApi() {
                try {
                    addLogEntry('Fetching inventory data from API...', 'info');
                    
                    // First try to get all component codes
                    for (const [key, itemCode] of Object.entries(componentItemCodes)) {
                        try {
                            const response = await fetch(`${API_URL}/item-master/?search=${itemCode}`);
                            if (response.ok) {
                                const data = await response.json();
                                if (data && data.length > 0) {
                                    // Save the verification code for this component
                                    componentCodeMap[key] = data[0].code || "";
                                    addLogEntry(`Found component code for ${key}: ${componentCodeMap[key]}`, 'info');
                                }
                            }
                        } catch (error) {
                            console.error(`Error fetching component code for ${key}:`, error);
                        }
                    }
                    
                    // Then get all sensor codes
                    // Special sensors (1, 16, 24)
                    for (const sensorId of [1, 16, 24]) {
                        try {
                            const response = await fetch(`${API_URL}/item-master/?search=${sensorItemCodes[sensorId]}`);
                            if (response.ok) {
                                const data = await response.json();
                                if (data && data.length > 0) {
                                    // Save the verification code for this sensor
                                    sensorCodeMap[sensorId] = data[0].code || "1";
                                    addLogEntry(`Found sensor code for sensor ${sensorId}: ${sensorCodeMap[sensorId]}`, 'info');
                                }
                            }
                        } catch (error) {
                            console.error(`Error fetching sensor code for sensor ${sensorId}:`, error);
                        }
                    }
                    
                    // Default sensors (2-15, 17-23)
                    try {
                        const response = await fetch(`${API_URL}/item-master/?search=${defaultSensorItemCode}`);
                        if (response.ok) {
                            const data = await response.json();
                            if (data && data.length > 0) {
                                const defaultCode = data[0].code || "1";
                                
                                // Apply to all default sensors
                                for (let i = 2; i <= 23; i++) {
                                    if (i !== 16 && i !== 24) { // Skip special sensors
                                        sensorCodeMap[i] = defaultCode;
                                    }
                                }
                                
                                addLogEntry(`Found default sensor code: ${defaultCode}`, 'info');
                            }
                        }
                    } catch (error) {
                        console.error(`Error fetching default sensor code:`, error);
                    }
                    
                    // Check if we have all the necessary codes
                    const hasAllComponentCodes = Object.keys(componentItemCodes).every(key => key in componentCodeMap);
                    const hasAllSensorCodes = Array.from({length: 24}, (_, i) => i + 1).every(i => i in sensorCodeMap);
                    
                    if (hasAllComponentCodes && hasAllSensorCodes) {
                        addLogEntry('All verification codes fetched successfully!', 'success');
                        apiInitialized = true;
                        return true;
                    } else {
                        // API didn't return all the necessary codes
                        showApiFailureMessage();
                        return false;
                    }
                } catch (error) {
                    console.error('Error fetching inventory data:', error);
                    showApiFailureMessage();
                    return false;
                }
            }

            // Function to verify code positions in barcode
            function verifyCodePositions(barcode, expectedCode) {
                if (!expectedCode || expectedCode === "") {
                    // If no expected code (like for sensors 23 and 24), it automatically passes
                    return true;
                }
                
                // Extract the characters at positions 5, 6, and 7 based on the length of expected code
                const codeLength = expectedCode.length;
                
                // Check if barcode is long enough
                if (barcode.length < 5) {
                    return false; // Barcode too short to check position 5
                }
                
                // For 1-character codes, check position 5
                if (codeLength === 1) {
                    return barcode.charAt(4) === expectedCode;
                }
                // For 2-character codes, check positions 5 and 6
                else if (codeLength === 2) {
                    return barcode.length >= 6 && 
                           barcode.charAt(4) === expectedCode.charAt(0) && 
                           barcode.charAt(5) === expectedCode.charAt(1);
                }
                // For 3-character codes, check positions 5, 6, and 7
                else if (codeLength === 3) {
                    return barcode.length >= 7 && 
                           barcode.charAt(4) === expectedCode.charAt(0) && 
                           barcode.charAt(5) === expectedCode.charAt(1) && 
                           barcode.charAt(6) === expectedCode.charAt(2);
                }
                
                return false;
            }
            
            // Function to update progress bar
            function updateProgress() {
                const totalItems = 30; // 6 components + 24 sensors
                const scannedCount = scannedSensors.length;
                const progressPercent = Math.round((scannedCount / totalItems) * 100);
                
                progressFill.style.width = `${progressPercent}%`;
                progressPercentage.textContent = `${progressPercent}%`;
            }

            // Generate a random barcode with '2' in 5th position and '5' in 6th position
            function generateAssemblyBarcode() {
                // Generate random digits for positions 1-4
                const prefix = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
                
                // Generate random digits for positions 7-11
                const suffix = Math.floor(Math.random() * 100000).toString().padStart(5, '0');
                
                // Combine with fixed '2' in 5th position and '5' in 6th position
                return prefix + '25' + suffix;
            }

            // Function to render barcode image
            function renderBarcode(elementId, barcodeValue) {
                try {
                    JsBarcode(`#${elementId}`, barcodeValue, {
                        format: "CODE128",
                        lineColor: "#000",
                        width: 2,
                        height: 60,
                        displayValue: true,
                        fontSize: 16,
                        margin: 10
                    });
                } catch (e) {
                    console.error("JsBarcode rendering failed:", e);
                    const element = document.getElementById(elementId);
                    if (element) {
                        element.textContent = `Error rendering barcode: ${barcodeValue}`;
                    }
                }
            }

            // Function to store completed work order in localStorage
            function storeCompletedWorkOrder(orderData) {
                try {
                    // Get existing completed orders from both storage locations
                    const completedOrders = JSON.parse(localStorage.getItem('completedWorkOrders') || '[]');
                    const assemblyCompletedOrders = JSON.parse(localStorage.getItem('assemblyCompletedOrders') || '[]');

                    // Create the completed order object structure expected by Assembly.jsx
                    const completedEntry = {
                        id: orderData.id,
                        status: 'Completed',
                        product: orderData.product || `YBS 24-Duct Assembly`, 
                        item_code: orderData.item_code || '5YB011057',
                        serial_number: orderData.barcode_number, // Use the generated barcode
                        completed_at: orderData.completed_at,
                        reworked: orderData.reworked || false,
                        metadata: {
                            scanned_parts: orderData.metadata?.scanned_parts || []
                        }
                    };

                    // Add to 'completedWorkOrders' if not already present
                    if (!completedOrders.some(order => order.id === orderData.id)) {
                        completedOrders.push(completedEntry);
                        localStorage.setItem('completedWorkOrders', JSON.stringify(completedOrders));
                    }

                    // Add to 'assemblyCompletedOrders' if not already present
                    if (!assemblyCompletedOrders.some(order => order.id === orderData.id)) {
                        assemblyCompletedOrders.push(completedEntry);
                        localStorage.setItem('assemblyCompletedOrders', JSON.stringify(assemblyCompletedOrders));
                    }

                    addLogEntry(`Assembly ${orderData.id} saved to completed orders locally`, 'success');
                } catch (error) {
                    console.error('Error storing completed work order locally:', error);
                    addLogEntry('Failed to store completion status locally', 'warning');
                }
            }

            // Function to move a work order from pending to completed in localStorage
            function moveWorkOrderToCompleted(assemblyId) {
                try {
                    // Get pending and completed work orders from localStorage
                    const pendingWorkOrders = JSON.parse(localStorage.getItem('pendingWorkOrders') || '[]');
                    const completedWorkOrders = JSON.parse(localStorage.getItem('assemblyCompletedOrders') || '[]');

                    // Find the work order in pending list
                    const workOrderIndex = pendingWorkOrders.findIndex(order => order.id === assemblyId);

                    if (workOrderIndex !== -1) {
                        // Remove from pending
                        const workOrder = pendingWorkOrders.splice(workOrderIndex, 1)[0];

                        // Mark as completed
                        workOrder.status = 'Completed';
                        workOrder.completed_at = new Date().toISOString();

                        // Add to completed if not already there
                        if (!completedWorkOrders.some(order => order.id === assemblyId)) {
                            completedWorkOrders.push(workOrder);
                        }

                        // Save updated lists back to localStorage
                        localStorage.setItem('pendingWorkOrders', JSON.stringify(pendingWorkOrders));
                        localStorage.setItem('assemblyCompletedOrders', JSON.stringify(completedWorkOrders));

                        addLogEntry(`Work order ${assemblyId} moved from pending to completed locally`, 'success');
                    } else {
                        addLogEntry(`Work order ${assemblyId} not found in local pending list`, 'warning');
                    }
                } catch (error) {
                    console.error('Error moving work order locally:', error);
                    addLogEntry('Error updating local work order status', 'error');
                }
            }

            // Fetch work order details for proper data in completed work orders
            async function fetchWorkOrderDetails(workOrderId) {
                if (!workOrderId) return null;
                try {
                    const response = await fetch(`/api/work-order/${workOrderId}/`);
                    if (response.ok) {
                        const woData = await response.json();
                        currentWorkOrderDetails = {
                            id: woData.id,
                            item_code: woData.item_code,
                            product: woData.product
                        };
                        addLogEntry(`Fetched details for Work Order: ${woData.item_code} - ${woData.product}`, 'info');
                        return currentWorkOrderDetails;
                    }
                } catch (error) {
                    console.error('Failed to fetch work order details:', error);
                    addLogEntry(`Failed to fetch details for Work Order #${workOrderId}`, 'warning');
                }
                return null;
            }

            // Component definitions for YBS Machine - 24 Duct Assembly
            const components = {
                // PCBs
                "left_pcb": {
                    barcode: "V22CL0065",
                    name: "Left Slave PCB",
                    element: document.querySelector('.left-pcb'),
                    scanned: false,
                    index: 1,
                    item_code: componentItemCodes.left_pcb
                },
                "master_pcb": {
                    barcode: "V22C80087",
                    name: "Master PCB",
                    element: document.querySelector('.master-pcb'),
                    scanned: false,
                    index: 2,
                    item_code: componentItemCodes.master_pcb
                },
                "right_pcb": {
                    barcode: "V22CR0129",
                    name: "Right Slave PCB",
                    element: document.querySelector('.right-pcb'),
                    scanned: false,
                    index: 3,
                    item_code: componentItemCodes.right_pcb
                },
                
                // Board-to-Board connections
                "b2b_left_master": {
                    barcode: "P22BV0584",
                    name: "Board-to-Board (Left to Master)",
                    element: document.querySelectorAll('.board-to-board')[0],
                    scanned: false,
                    index: 4,
                    item_code: componentItemCodes.b2b_left_master
                },
                "b2b_master_right": {
                    barcode: "P22BV0476",
                    name: "Board-to-Board (Master to Right)",
                    element: document.querySelectorAll('.board-to-board')[1],
                    scanned: false,
                    index: 5,
                    item_code: componentItemCodes.b2b_master_right
                },
                
                // Power & Communication Cable
                "pc_cable": {
                    barcode: "P22AQ0131",
                    name: "Power & Communication Cable",
                    element: document.querySelector('.power-cable'),
                    scanned: false,
                    index: 6,
                    item_code: componentItemCodes.pc_cable
                }
            };
            
            // Function to add log entry
            function addLogEntry(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logItem = document.createElement('div');
                logItem.classList.add('log-entry', type);
                logItem.innerHTML = `
                    <span class="log-time">${timestamp}</span>
                    <span class="log-message">${message}</span>
                `;

                // Append the log entry to the logs container
                logsContent.appendChild(logItem);

                // Automatically scroll to the latest log entry
                logsContent.scrollTop = logsContent.scrollHeight;
            }
            function showNotification(message, type = 'info') {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.className = 'notification';
                notification.classList.add(type);
                notification.style.display = 'block';
                
                setTimeout(() => {
                    notification.style.opacity = '1';
                }, 10);
                
                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => {
                        notification.style.display = 'none';
                    }, 300);
                }, 3000);
            }
            
            // Function to add log entry
            function addLogEntry(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logItem = document.createElement('div');
                logItem.classList.add('log-item', type);
                logItem.innerHTML = `
                    <span class="log-time">${timestamp}</span>
                    <span class="log-message">${message}</span>
                `;
                logsContent.appendChild(logItem);
                logsContent.scrollTop = logsContent.scrollHeight;
            }

            // Function to update progress bar
            function updateProgress() {
                const totalItems = 29; // 6 components + 23 sensors
                let scannedCount = scannedSensors.length;
                
                // Ensure we don't exceed 100%
                if (scannedCount > totalItems) scannedCount = totalItems;
                
                const progressPercent = Math.round((scannedCount / totalItems) * 100);
                
                progressFill.style.width = `${progressPercent}%`;
                progressPercentage.textContent = `${progressPercent}%`;
            }
            // Function to save current scan to the database
            async function saveCurrentScan(scanData) {
                try {
                    const response = await fetch(`${API_URL}/save-scan/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(scanData)
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to save scan data');
                    }
                    
                    const data = await response.json();
                    return data;
                } catch (error) {
                    console.error('Error saving scan data:', error);
                }
            }
            // Function to update current sensor index in the database
            async function updateCurrentSensorIndex() {
                try {
                    const response = await fetch(`${API_URL}/update-sensor-index/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ sensorIndex: currentSensorIndex })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to update sensor index');
                    }
                    
                    const data = await response.json();
                    return data;
                } catch (error) {
                    console.error('Error updating sensor index:', error);
                }
            }
            // Function to handle barcode scanning

            async function handleBarcodeScan() {
                const barcode = barcodeInput.value.trim();
                
                if (barcode === "") {
                    showNotification('Please enter a barcode.', 'error');
                    return;
                }
                
                // Verify the barcode
                const isValid = await verifyBarcode(barcode);
                
                if (isValid) {
                    // Clear the input field
                    barcodeInput.value = '';
                    
                    // Focus on the input field for the next scan
                    barcodeInput.focus();
                } else {
                    showNotification('Invalid barcode. Please try again.', 'error');
                }
            }

            // Event listener for scan button
            scanButton.addEventListener('click', handleBarcodeScan);
            // Event listener for barcode input
            barcodeInput.addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    handleBarcodeScan();
                }
            });
            // Event listener for complete button
            completeButton.addEventListener('click', async function() {
                if (scannedSensors.length === 30) {
                    // All components and sensors scanned
                    showNotification('All components and sensors verified successfully!', 'success');
                    
                    // Optionally, you can redirect or perform other actions here
                } else {
                    showNotification('Please scan all components and sensors before completing.', 'error');
                }
            });
            
            // Function to show notification
            function showNotification(message, type = 'info') {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.className = 'notification';
                notification.classList.add(type);
                notification.classList.add('show');
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);
            }
            
            // Function to verify barcode
            async function verifyBarcode(barcode) {
                if (!apiInitialized) {
                    showNotification('API connection not initialized. Unable to verify barcodes.', 'error');
                    return false;
                }
                
                const trimmedBarcode = barcode.trim();
                
                // Check if we're scanning components first (PCBs, cables, etc.)
                if (currentSensorIndex <= 6) {
                    // We're in component scanning phase (index 1-6)
                    const componentsArray = Object.values(components).sort((a, b) => a.index - b.index);
                    const nextComponent = componentsArray.find(comp => !comp.scanned);
                    
                    if (!nextComponent) {
                        // All components scanned, start scanning sensors
                        currentSensorIndex = 7; // Start at sensor index 7 (1st sensor)
                        showNotification("All components verified! Start scanning sensors in sequence.", "success");
                        
                        // Mark the first sensor as next
                        if (sensorCells[1]) {
                            // Clear any existing 'next' markers
                            document.querySelectorAll('.next').forEach(cell => {
                                cell.classList.remove('next');
                            });
                            sensorCells[1].classList.add('next');
                        }
                        
                        // Update tooltip with code information
                        const expectedCode = sensorCodeMap[1];
                        const codeInfo = expectedCode ? ` (Code: ${expectedCode})` : ' (No code required)';
                        sensorCells[1].setAttribute('data-tooltip', `Sensor #1 - Next to scan${codeInfo}`);
                        
                        return false;
                    }
                    
                    // Get the component type and expected code
                    const componentType = Object.keys(components).find(key => components[key].index === nextComponent.index);
                    const expectedCode = componentCodeMap[componentType];
                    
                    // Verify the code in the specific positions
                    if (verifyCodePositions(trimmedBarcode, expectedCode)) {
                        // Success - mark the component as scanned
                        nextComponent.scanned = true;
                        nextComponent.element.style.backgroundColor = 'var(--status-success)';
                        
                        // Add to scanned sensors list
                        const newScan = {
                            sensorId: `component_${nextComponent.index}`,
                            barcode: trimmedBarcode,
                            timestamp: new Date(),
                            status: 'success',
                            componentName: nextComponent.name,
                            item_code: nextComponent.item_code
                        };
                        
                        scannedSensors.push(newScan);
                        
                        // Save this scan to the database
                        await saveCurrentScan({
                            sensorId: nextComponent.index,
                            barcode: trimmedBarcode,
                            item_code: nextComponent.item_code
                        });
                        
                        // Add log entry
                        addLogEntry(`${nextComponent.name} verified successfully: ${trimmedBarcode} (Item: ${nextComponent.item_code}, Code: ${expectedCode})`, 'success');
                        
                        // Show notification
                        showNotification(`${nextComponent.name} verified successfully!`, 'success');
                        
                        // Check if all components are scanned
                        const allComponentsScanned = Object.values(components).every(comp => comp.scanned);
                        
                        if (allComponentsScanned) {
                            // All components scanned, start scanning sensors
                            currentSensorIndex = 7; // Start at sensor index 7 (1st sensor)
                            
                            // Update the current sensor index in the database
                            await updateCurrentSensorIndex();
                            
                            // Mark the first sensor as next
                            if (sensorCells[1]) {
                                // Clear any existing 'next' markers
                                document.querySelectorAll('.next').forEach(cell => {
                                    cell.classList.remove('next');
                                });
                                sensorCells[1].classList.add('next');
                            }
                            
                            // Update tooltip to indicate next sensor with code
                            const expectedCode = sensorCodeMap[1];
                            const codeInfo = expectedCode ? ` (Code: ${expectedCode})` : ' (No code required)';
                            sensorCells[1].setAttribute('data-tooltip', `Sensor #1 - Next to scan${codeInfo}`);
                            
                            addLogEntry('All components scanned! Now scan sensors in sequence.', 'info');
                            showNotification('All components verified! Now scan sensors in sequence.', 'success');
                        } else {
                            // Find the next component to scan
                            const nextUpComponent = componentsArray.find(comp => !comp.scanned);
                            const nextComponentType = Object.keys(components).find(key => components[key].index === nextUpComponent.index);
                            const nextExpectedCode = componentCodeMap[nextComponentType];
                            
                            addLogEntry(`Next scan: ${nextUpComponent.name} (Expected code: ${nextExpectedCode})`, 'info');
                        }
                        
                        // Update progress
                        updateProgress();
                        
                        return true;
                    } else {
                        // Error - code in positions doesn't match
                        addLogEntry(`Error: Expected code ${expectedCode} for ${nextComponent.name}, got incorrect code at positions 5${expectedCode.length > 1 ? `-${4 + expectedCode.length}` : ""}`, 'error');
                        showNotification(`Wrong code for ${nextComponent.name}! Expected ${expectedCode} at position${expectedCode.length > 1 ? "s" : ""} 5${expectedCode.length > 1 ? `-${4 + expectedCode.length}` : ""}`, 'error');
                        
                        // Add visual effect for error
                        const originalColor = nextComponent.element.style.backgroundColor;
                        nextComponent.element.style.backgroundColor = 'var(--status-error)';
                        setTimeout(() => {
                            nextComponent.element.style.backgroundColor = originalColor;
                        }, 1000);
                        
                        return false;
                    }
                } else {
                    // We're scanning sensors (sensorIndex >= 7)
                    const sensorIdToCheck = currentSensorIndex - 6; // Convert from sequence index to sensor ID
                    const expectedCode = sensorCodeMap[sensorIdToCheck];
                    
                    // Get the item code for this sensor
                    let sensorItemCode;
                    if ([1, 16, 24].includes(sensorIdToCheck)) {
                        sensorItemCode = sensorItemCodes[sensorIdToCheck]; // Special sensors
                    } else {
                        sensorItemCode = defaultSensorItemCode; // Default sensors
                    }
                    
                    // Verify the barcode at the specific positions
                    if (verifyCodePositions(trimmedBarcode, expectedCode)) {
                        // Success - mark the sensor as scanned
                        sensorCells[sensorIdToCheck].classList.remove('next');
                        sensorCells[sensorIdToCheck].classList.add('success');
                        
                        // Add to scanned sensors list
                        const newSensor = {
                            sensorId: sensorIdToCheck,
                            barcode: trimmedBarcode,
                            timestamp: new Date(),
                            status: 'success',
                            item_code: sensorItemCode
                        };
                        
                        scannedSensors.push(newSensor);
                        
                        // Save this scan to the database
                        await saveCurrentScan({
                            sensorId: currentSensorIndex, // Use original index for the API
                            barcode: trimmedBarcode,
                            item_code: sensorItemCode
                        });
                        
                        // Add log entry
                        const codeInfo = expectedCode ? ` (Code: ${expectedCode})` : ' (No code required)';
                        addLogEntry(`Sensor #${sensorIdToCheck} verified successfully: ${trimmedBarcode} (Item: ${sensorItemCode}${codeInfo})`, 'success');
                        
                        // Show notification
                        showNotification(`Sensor #${sensorIdToCheck} verified successfully!`, 'success');
                        
                        // Move to next sensor
                        currentSensorIndex++;
                        
                        // Update the current sensor index in the database
                        await updateCurrentSensorIndex();
                        
                        // Update progress
                        updateProgress();
                        
                        // Mark next sensor if available
                        const nextSensorId = currentSensorIndex - 6;
                        
                        if (nextSensorId <= 24) {
                            // Clear any existing 'next' markers
                            document.querySelectorAll('.next').forEach(cell => {
                                cell.classList.remove('next');
                            });
                            
                            // Mark the next sensor
                            if (sensorCells[nextSensorId]) {
                                sensorCells[nextSensorId].classList.add('next');
                                
                                // Get the next expected code
                                const nextExpectedCode = sensorCodeMap[nextSensorId];
                                const codeDisplay = nextExpectedCode ? ` (Code: ${nextExpectedCode})` : ' (No code required)';
                                
                                // Update tooltip to indicate next sensor
                                sensorCells[nextSensorId].setAttribute(
                                    'data-tooltip', 
                                    `Sensor #${nextSensorId} - Next to scan${codeDisplay}`
                                );
                            }
                        } else {
                            // All sensors scanned, show complete button
                            completeButton.classList.remove('hidden');
                            completeButton.disabled = false;
                            showNotification('All sensors verified! Click Complete to finish assembly.', 'success');
                        }
                        
                        return true;
                    } else {
                        // Error - code in positions doesn't match
                        const errorMessage = expectedCode ? 
                            `Error: Expected code ${expectedCode} at position${expectedCode.length > 1 ? "s" : ""} 5${expectedCode.length > 1 ? `-${4 + expectedCode.length}` : ""}` :
                            `Error: Incorrect sensor code for Sensor #${sensorIdToCheck}`;
                            
                        addLogEntry(errorMessage, 'error');
                        showNotification(`Wrong code for Sensor #${sensorIdToCheck}!`, 'error');
                        
                        // Add visual effect for error
                        const currentCell = sensorCells[sensorIdToCheck];
                        currentCell.classList.add('error');
                        setTimeout(() => {
                            currentCell.classList.remove('error');
                        }, 1000);
                        
                        return false;
                    }
                }
            }
            
            // Initialize the page
            async function initPage() {
                // Try to fetch verification codes from API
                const apiSuccess = await initializeApi();
                
                // Check if API initialization was successful
                if (!apiSuccess) {
                    showNotification("API connection failed. Cannot proceed with assembly.", "error");
                    return;
                }
                
                await loadAssemblyState();
                
                // Update the components with item codes
                Object.keys(components).forEach(key => {
                    components[key].item_code = componentItemCodes[key];
                });

                // Display component item codes in logs for reference
                addLogEntry('Starting assembly. Component item codes:', 'info');
                Object.keys(components).forEach(key => {
                    const component = components[key];
                    const expectedCode = componentCodeMap[key];
                    addLogEntry(`${component.index}. ${component.name} - Item Code: ${component.item_code}, Code: ${expectedCode}`, 'info');
                });
                
                addLogEntry('After components, scan all 24 sensors in sequence', 'info');
                
                // Focus the barcode input
                barcodeInput.focus();
            }

            // Add createAssemblyProcess and loadAssemblyState functions for completeness
            async function createAssemblyProcess(workOrderId) {
                try {
                    // Fetch details for the selected work order before creating assembly process
                    await fetchWorkOrderDetails(workOrderId);

                    // Create a new assembly process
                    const assemblyData = {
                        work_order: workOrderId,
                        assembly_type: 'YBS',
                        status: 'in_progress',
                        metadata: {
                            current_sequence_index: 1,
                            scanned_sensors: []
                        }
                    };

                    const response = await fetch('/api/assembly-process/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(assemblyData)
                    });

                    if (!response.ok) {
                        throw new Error('Failed to create assembly process');
                    }

                    const data = await response.json();
                    assemblyId = data.id;

                    // Store the assembly ID in localStorage
                    localStorage.setItem('currentYBS24AssemblyId', assemblyId);
                    localStorage.setItem('currentSensorIndex', '1');

                    addLogEntry(`Created new assembly process with ID: ${assemblyId}`, 'success');
                    return data;
                } catch (error) {
                    console.error('Error creating assembly process:', error);
                    addLogEntry(`Error creating assembly process: ${error.message}`, 'error');
                    return null;
                }
            }

            async function loadAssemblyState() {
                // Get assembly ID from localStorage or URL parameters
                const params = new URLSearchParams(window.location.search);
                const id = localStorage.getItem('currentYBS24AssemblyId') || params.get('assemblyId');
                const workOrderId = params.get('workOrderId');

                if (!id && workOrderId) {
                    // No existing assembly, but we have a work order ID
                    // Create a new assembly process
                    return await createAssemblyProcess(workOrderId);
                } else if (!id) {
                    // No assembly ID and no work order ID
                    addLogEntry('No assembly ID found. Please start a new assembly from the dashboard.', 'warning');
                    return false;
                }

                // We have an assembly ID, load its state
                assemblyId = id;

                try {
                    const response = await fetch(`/api/assembly-process/${id}/`);
                    if (!response.ok) {
                        throw new Error('Failed to load assembly process');
                    }

                    const data = await response.json();

                    // Fetch associated work order details if not already loaded
                    if (!currentWorkOrderDetails && data.work_order) {
                        await fetchWorkOrderDetails(data.work_order);
                    }

                    // Set the current sensor index from metadata or localStorage
                    if (data.metadata && data.metadata.current_sequence_index) {
                        currentSensorIndex = data.metadata.current_sequence_index;
                    } else {
                        const savedIndex = localStorage.getItem('currentSensorIndex');
                        if (savedIndex) {
                            currentSensorIndex = parseInt(savedIndex);
                        }
                    }

                    // Load scanned sensors from metadata or localStorage
                    if (data.metadata && data.metadata.scanned_sensors) {
                        // Load from API data
                        const apiScannedSensors = data.metadata.scanned_sensors;
                        for (const sensor of apiScannedSensors) {
                            scannedSensors.push({
                                sensorId: sensor.id,
                                barcode: sensor.barcode,
                                timestamp: sensor.scan_time,
                                status: 'success'
                            });
                        }
                    } else {
                        // Try to load from localStorage
                        const savedScannedSensors = localStorage.getItem('scannedSensors');
                        if (savedScannedSensors) {
                            scannedSensors = JSON.parse(savedScannedSensors);
                        }
                    }

                    // Update the UI to reflect the loaded state
                    updateProgress();
                    
                    // Highlight next item
                    if (currentSensorIndex <= 6) {
                        const componentsArray = Object.values(components).sort((a, b) => a.index - b.index);
                        const nextComponent = componentsArray.find(comp => !comp.scanned);
                        if (nextComponent) {
                            nextComponent.element.classList.add('next');
                        }
                    } else {
                        const sensorIdToHighlight = currentSensorIndex - 6;
                        if (sensorCells[sensorIdToHighlight]) {
                            sensorCells[sensorIdToHighlight].classList.add('next');
                        }
                    }

                    addLogEntry(`Loaded assembly process #${id}. Current sensor index: ${currentSensorIndex}`, 'info');
                    return true;
                } catch (error) {
                    console.error('Error loading assembly state:', error);
                    addLogEntry(`Error loading assembly: ${error.message}`, 'error');
                    return false;
                }
            }

            // Replace the existing completeButton click handler with this enhanced version
            completeButton.addEventListener('click', async function() {
                // Disable the button to prevent double-clicks
                completeButton.disabled = true;
                
                try {
                    // Verify all items are scanned (24 sensors + 6 components = 30 items)
                    if (scannedSensors.length < 30) {
                        showNotification(`Cannot complete: Only ${scannedSensors.length}/30 items scanned.`, 'error');
                        addLogEntry(`Completion blocked: Not all items scanned.`, 'error');
                        completeButton.disabled = false;
                        return;
                    }
                    
                    // Show processing message
                    showNotification('Processing...', 'info');
                    addLogEntry('Completing assembly process...', 'info');

                    // Generate the final assembly barcode
                    const finalAssemblyBarcode = generateAssemblyBarcode();
                    addLogEntry(`Generated Assembly Barcode: ${finalAssemblyBarcode}`, 'info');

                    // Prepare detailed scanned parts data
                    const scannedPartsDetails = [];
                    
                    // Add components
                    Object.entries(components).forEach(([key, comp]) => {
                        if (comp.scanned) {
                            // Handle timestamp safely
                            let formattedScanTime;
                            try {
                                const scanData = scannedSensors.find(s => s.sensorId === `component_${comp.index}`);
                                const scanTime = scanData?.timestamp || new Date();
                                
                                if (scanTime instanceof Date) {
                                    formattedScanTime = scanTime.toISOString();
                                } else if (typeof scanTime === 'string') {
                                    formattedScanTime = scanTime;
                                } else {
                                    formattedScanTime = new Date().toISOString();
                                }
                            } catch (e) {
                                formattedScanTime = new Date().toISOString();
                            }

                            scannedPartsDetails.push({
                                type: 'component',
                                id: key,
                                name: comp.name,
                                item_code: comp.item_code,
                                scanned_barcode: comp.scannedBarcode || 'N/A',
                                scan_time: formattedScanTime
                            });
                        }
                    });
                    
                    // Add sensors
                    scannedSensors.forEach(sensor => {
                        if (sensor && sensor.status === 'success' && 
                            typeof sensor.sensorId === 'number' || 
                            (typeof sensor.sensorId === 'string' && sensor.sensorId.startsWith('component_'))) {
                            
                            // Skip components, only include actual sensors
                            if (typeof sensor.sensorId === 'string' && sensor.sensorId.startsWith('component_')) {
                                return; // Skip to next iteration
                            }
                            
                            // Handle timestamp safely
                            let formattedTimestamp;
                            try {
                                if (sensor.timestamp instanceof Date) {
                                    formattedTimestamp = sensor.timestamp.toISOString();
                                } else if (typeof sensor.timestamp === 'string') {
                                    formattedTimestamp = sensor.timestamp;
                                } else {
                                    formattedTimestamp = new Date().toISOString();
                                }
                            } catch (e) {
                                formattedTimestamp = new Date().toISOString();
                            }
                            
                            // Find the item code for this sensor
                            let itemCode;
                            if ([1, 16, 24].includes(sensor.sensorId)) {
                                itemCode = sensorItemCodes[sensor.sensorId];
                            } else {
                                itemCode = defaultSensorItemCode;
                            }

                            scannedPartsDetails.push({
                                type: 'sensor',
                                id: sensor.sensorId,
                                name: `Sensor #${sensor.sensorId}`,
                                item_code: itemCode,
                                scanned_barcode: sensor.barcode,
                                scan_time: formattedTimestamp
                            });
                        }
                    });

                    // Prepare data for API submission
                    const assemblyData = {
                        status: 'completed',
                        completed_at: new Date().toISOString(),
                        notes: 'Assembly completed via YBS 24-Duct assembly interface',
                        operator: 'Current User', // Replace with actual user if available
                        barcode_number: finalAssemblyBarcode,
                        metadata: {
                            current_sequence_index: currentSensorIndex,
                            scanned_parts: scannedPartsDetails
                        }
                    };

                    // Make the API call to update the assembly process
                    const response = await fetch(`/api/assembly-process/${assemblyId}/`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(assemblyData)
                    });

                    if (!response.ok) {
                        const errorData = await response.text();
                        throw new Error(`Failed to complete assembly: ${response.status} ${response.statusText} - ${errorData}`);
                    }

                    const data = await response.json();

                    // Create data object for local storage functions
                    const localStorageOrderData = {
                        id: assemblyId,
                        product: currentWorkOrderDetails?.product || 'YBS 24-Duct Assembly',
                        item_code: currentWorkOrderDetails?.item_code || '5YB011057',
                        barcode_number: finalAssemblyBarcode,
                        completed_at: assemblyData.completed_at,
                        metadata: assemblyData.metadata
                    };

                    // Update localStorage to move this order to completed
                    storeCompletedWorkOrder(localStorageOrderData);
                    moveWorkOrderToCompleted(assemblyId);

                    // Success - show notification and final screen
                    showNotification('Assembly completed successfully!', 'success');
                    addLogEntry(`Assembly ${assemblyId} completed successfully! Final Barcode: ${finalAssemblyBarcode}`, 'success');

                    // Clear localStorage for this specific assembly on completion
                    localStorage.removeItem('currentYBS24AssemblyId');
                    localStorage.removeItem('currentSensorIndex');
                    localStorage.removeItem('scannedSensors');

                    // Display completion screen with barcode
                    document.getElementById('mainContainer').innerHTML = `
                        <div style="text-align: center; padding: 2rem; background-color: #f0fdf4; border: 1px solid #bbf7d0; border-radius: 0.5rem;">
                            <h2 style="color: #16a34a; margin-bottom: 1rem">Assembly Completed Successfully!</h2>
                            <p style="margin-bottom: 0.5rem">Assembly ID: ${assemblyId}</p>
                            <p style="margin-bottom: 1.5rem">24-Duct YBS Assembly</p>

                            <div style="background-color: #f1f5f9; border-radius: 0.5rem; padding: 1.5rem; margin-bottom: 2rem; display: inline-block;">
                                <h3 style="margin-bottom: 1rem; color: #334155;">Generated Assembly Barcode</h3>
                                <svg id="finalAssemblyBarcode" style="max-width: 100%; height: auto;"></svg>
                            </div>

                            <div style="margin-top: 2rem; display: flex; gap: 1rem; justify-content: center">
                                <button onclick="window.location.href='/assembly'"
                                        style="background: #3b82f6; color: white; padding: 0.75rem 1.5rem;
                                            border: none; border-radius: 0.375rem; cursor: pointer;">
                                    Return to Assembly List
                                </button>
                            </div>
                        </div>
                    `;

                    // Render the barcode image
                    renderBarcode('finalAssemblyBarcode', finalAssemblyBarcode);
                } catch (error) {
                    console.error('Error completing assembly:', error);
                    showNotification(`Failed to complete assembly: ${error.message}`, 'error');
                    addLogEntry(`Error completing assembly: ${error.message}`, 'error');
                    completeButton.disabled = false;
                }
            });

            // Start initialization
            initPage();
        });
    </script>
</head>
<body>
    <div class="container" id="mainContainer">
        <div class="header">
            <div class="part-id">5YB011057</div>
            <h1 class="title">YBS Machine - Duct Number 41 - 24 Duct Assembly</h1>
        </div>

        <div class="board-to-board-title">Board to Board</div>

        <div class="circuit-lines"></div>
        <div class="glow"></div>

        <table class="circuit-table" id="circuitTable">
            <tr>
                <td class="component-name">Magnetic<br>Coil Sensor</td>
                <td class="sensor-cell cell next" data-sensor-id="1" data-tooltip="Sensor #1 - Next to scan">1</td>
                <td class="sensor-cell cell" data-sensor-id="2" data-tooltip="Sensor #2">2</td>
                <td class="sensor-cell cell" data-sensor-id="3" data-tooltip="Sensor #3">3</td>
                <td class="sensor-cell cell" data-sensor-id="4" data-tooltip="Sensor #4">4</td>
                <td class="sensor-cell cell" data-sensor-id="5" data-tooltip="Sensor #5">5</td>
                <td class="sensor-cell cell" data-sensor-id="6" data-tooltip="Sensor #6">6</td>
                <td class="sensor-cell cell" data-sensor-id="7" data-tooltip="Sensor #7">7</td>
                <td class="sensor-cell cell" data-sensor-id="8" data-tooltip="Sensor #8">8</td>
                <td class="sensor-cell cell" data-sensor-id="9" data-tooltip="Sensor #9">9</td>
                <td class="sensor-cell cell" data-sensor-id="10" data-tooltip="Sensor #10">10</td>
                <td class="sensor-cell cell" data-sensor-id="11" data-tooltip="Sensor #11">11</td>
                <td class="sensor-cell cell" data-sensor-id="12" data-tooltip="Sensor #12">12</td>
                <td class="sensor-cell cell" data-sensor-id="13" data-tooltip="Sensor #13">13</td>
                <td class="sensor-cell cell" data-sensor-id="14" data-tooltip="Sensor #14">14</td>
                <td class="sensor-cell cell" data-sensor-id="15" data-tooltip="Sensor #15">15</td>
                <td class="sensor-cell cell" data-sensor-id="16" data-tooltip="Sensor #16">16</td>
                <td class="sensor-cell cell" data-sensor-id="17" data-tooltip="Sensor #17">17</td>
                <td class="sensor-cell cell" data-sensor-id="18" data-tooltip="Sensor #18">18</td>
                <td class="sensor-cell cell" data-sensor-id="19" data-tooltip="Sensor #19">19</td>
                <td class="sensor-cell cell" data-sensor-id="20" data-tooltip="Sensor #20">20</td>
                <td class="sensor-cell cell" data-sensor-id="21" data-tooltip="Sensor #21">21</td>
                <td class="sensor-cell cell" data-sensor-id="22" data-tooltip="Sensor #22">22</td>
                <td class="sensor-cell cell" data-sensor-id="23" data-tooltip="Sensor #23">23</td>
                <td class="sensor-cell cell" data-sensor-id="24" data-tooltip="Sensor #24">24</td>
            </tr>
            <tr>
                <td class="component-name">PCB BOARD</td>
                <td class="left-pcb cell" colspan="8" data-tooltip="Left Slave PCB - Controls sensors 1-8">Assembled YBS ILI Slave Left PCB - BL Ver - T - REV 1</td>
                <td class="master-pcb cell" colspan="8" data-tooltip="Master PCB - Controls all 24 spindles">Assembled YBS ILI Master PCB - 24 Spindles -BL-T Ver-REV 1</td>
                <td class="right-pcb cell" colspan="8" data-tooltip="Right Slave PCB - Controls sensors 17-24">Assembled YBS ILI Slave Right PCB - BL Ver - T - REV 1</td>
            </tr>
            <tr>
                <td class="component-name">Joining Cable</td>
                <td class="empty-cell" colspan="7"></td>
                <td class="board-to-board cell" colspan="2" data-tooltip="Connection between Left PCB and Master PCB">Board to<br>Board</td>
                <td class="empty-cell" colspan="7"></td>
                <td class="board-to-board cell" colspan="2" data-tooltip="Connection between Master PCB and Right PCB">Board to<br>Board</td>
                <td class="empty-cell" colspan="6"></td>
            </tr>
            <tr>
                <td class="component-name">P&C Cable</td>
                <td class="power-cable cell" colspan="24" data-tooltip="Power & Communication Cable - 1680mm length">YBS POWER & COMMUNICATION CABLE ASSY -1680mm - RR</td>
            </tr>
        </table>

        <div id="tooltip" class="tooltip"></div>
        <div id="connectionLine1" class="connection-line"></div>
        <div id="connectionLine2" class="connection-line"></div>

        <div class="scan-section">
            <h2 class="text-xl font-semibold mb-4">Sensor Barcode Verification</h2>
            
            <div id="errorMessage" class="notification-error"></div>
            
            <div class="scan-input-container">
                <input type="text" id="barcodeInput" class="scan-input" placeholder="Scan sensor barcode..." autofocus>
                <button id="scanButton" class="scan-button">Verify</button>
            </div>
            
            <div class="progress-container">
                <div class="progress-header">
                    <div class="progress-label">Assembly Progress</div>
                    <div class="progress-percentage" id="progressPercentage">0%</div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
            </div>
            
            <div class="logs-container">
                <div class="log-header">Assembly Logs</div>
                <div id="logsContent"></div>
            </div>
            
            <div class="scan-controls">
                <button id="completeButton" class="complete-button hidden" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                        <polyline points="22 4 12 14.01 9 11.01"></polyline>
                    </svg>
                    Complete Assembly
                </button>
                
                <button id="restartButton" class="restart-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M1 4v6h6"></path>
                        <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
                    </svg>
                    Restart Assembly
                </button>
            </div>
        </div>
    </div>

    <div id="notification" class="notification"></div>
</body>
</html>
``` 