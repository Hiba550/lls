<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js"></script>

    <title>RSM Assembly - 5RS011075</title>
    <style>
        :root {
            --left-pcb-color: #b5e6b5;
            --master-pcb-color: #d3d3d3;
            --right-pcb-color: #a8e4f0;
            --slave-pcb-color: #d2c7f7;
            --highlight-yellow: #ffeb3b;
            --board-to-board-color: #999;
            --slave-to-slave-cable: #ffd700;
            --master-to-slave-cable: #ff9e3d;
            --pc-cable-bg: #f0f0f0;
            --border-color: #aaa;
            --hover-shadow: 0 0 10px rgba(0, 123, 255, 0.3);
            --transition-speed: 0.2s;
            --bg-color-body: #f8f8f8;
            --bg-color-container: #fff;
            --text-color-dark: #333;
            --text-color-light: #f1f5f9;
            --header-border-color: #ddd;
            --component-name-bg: #e9ecef;
            --component-name-text: var(--text-color-dark);
            --tooltip-bg: rgba(54, 69, 79, 0.95);
            --tooltip-text: var(--text-color-light);
            --status-success: #4caf50;
            --status-error: #f44336;
            --status-warning: #ff9800;
            --status-info: #2196f3;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 1.5rem;
            background-color: var(--bg-color-body);
            color: var(--text-color-dark);
            line-height: 1.5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--bg-color-container);
            border-radius: 0.5rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            padding: 2rem;
            position: relative;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
            position: relative;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--header-border-color);
        }

        .title {
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--text-color-dark);
            margin-bottom: 0.75rem;
            text-shadow: 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .part-id {
            position: absolute;
            left: 0;
            top: 0;
            background-color: #f97316;
            color: var(--text-color-light);
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-weight: 600;
            font-size: 0.875rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .board-to-board-title {
            color: #38bdf8;
            font-size: 2rem;
            font-weight: 700;
            text-align: center;
            margin: 1.5rem 0;
            text-shadow: 0 0 5px rgba(56, 189, 248, 0.4);
            position: relative;
        }

        .board-to-board-title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            height: 3px;
            background: linear-gradient(90deg, transparent, #38bdf8, transparent);
        }

        .circuit-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            border: 1.5px solid var(--border-color);
            border-radius: 0.375rem;
            overflow: hidden;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            position: relative;
            z-index: 10;
            background-color: #fff;
        }

        .circuit-table td {
            border: 1px solid var(--border-color);
            padding: 0.5rem 0.25rem;
            font-size: 0.75rem;
            height: 2.5rem;
            position: relative;
            transition: all var(--transition-speed) ease;
        }

        .component-name {
            text-align: left;
            font-weight: 700;
            padding-left: 1rem;
            background-color: var(--component-name-bg);
            color: var(--component-name-text);
            width: 8rem;
            vertical-align: middle;
            position: relative;
            overflow: hidden;
        }

        .component-name::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 10px;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0,0,0,0.05));
        }

        .cell {
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            border-radius: 3px;
        }

        .cell:hover {
            transform: scale(1.05);
            box-shadow: var(--hover-shadow);
            z-index: 100;
        }

        .slave-pcb {
            background-color: var(--slave-pcb-color);
            text-align: center;
            font-size: 0.7rem;
            font-weight: 500;
            padding: 0.75rem 0.25rem;
            line-height: 1.3;
            vertical-align: middle;
            position: relative;
            cursor: pointer;
        }

        .slave-pcb::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, rgba(0,0,0,0.05), rgba(0,0,0,0.1), rgba(0,0,0,0.05));
        }

        .master-pcb {
            background-color: var(--master-pcb-color);
            color: var(--text-color-dark);
            text-align: center;
            font-size: 0.7rem;
            font-weight: 500;
            padding: 0.75rem 0.25rem;
            line-height: 1.3;
            vertical-align: middle;
            position: relative;
            cursor: pointer;
        }

        .master-pcb::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, rgba(0,0,0,0.05), rgba(0,0,0,0.1), rgba(0,0,0,0.05));
        }

        .board-to-board {
            background-color: var(--board-to-board-color);
            color: var(--text-color-dark);
            text-align: center;
            font-size: 0.7rem;
            font-weight: 500;
            line-height: 1.2;
            vertical-align: middle;
            background-image: linear-gradient(to bottom, rgba(0,0,0,0.05), transparent);
            cursor: pointer;
        }

        .empty-cell {
            background-color: #ffffff;
        }

        .cell.success {
            background-color: var(--status-success);
            color: white;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.6);
            animation: successPulse 2s ease-in-out;
        }

        @keyframes successPulse {
            0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.8); }
            70% { box-shadow: 0 0 10px 10px rgba(76, 175, 80, 0); }
            100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); }
        }

        .cell.error {
            background-color: var(--status-error);
            color: white;
            animation: errorShake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }

        @keyframes errorShake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }

        .cell.next {
            background-color: var(--highlight-yellow);
            animation: nextPulse 2s infinite;
            position: relative;
            overflow: hidden;
        }

        .cell.next::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes nextPulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.7); }
            70% { box-shadow: 0 0 10px 10px rgba(255, 235, 59, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 235, 59, 0); }
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .power-cable {
            background-color: var(--pc-cable-bg);
            text-align: center;
            font-weight: 600;
            font-size: 0.875rem;
            padding: 0.75rem 0.25rem;
            vertical-align: middle;
            background-image: linear-gradient(to bottom, #f9f9f9, #ffffff);
            cursor: pointer;
        }

        .circuit-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .circuit-lines::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                radial-gradient(circle at 10% 10%, rgba(59, 130, 246, 0.03) 1px, transparent 1px),
                radial-gradient(circle at 20% 50%, rgba(59, 130, 246, 0.03) 1px, transparent 1px),
                radial-gradient(circle at 30% 30%, rgba(59, 130, 246, 0.03) 1px, transparent 1px),
                radial-gradient(circle at 40% 70%, rgba(59, 130, 246, 0.03) 1px, transparent 1px),
                radial-gradient(circle at 50% 40%, rgba(59, 130, 246, 0.03) 1px, transparent 1px);
            background-size: 100px 100px;
        }

        .glow {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% 50%, rgba(56, 189, 248, 0.05), transparent 70%);
            pointer-events: none;
            z-index: 1;
        }

        .tooltip {
            position: absolute;
            background: var(--tooltip-bg);
            color: var(--tooltip-text);
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 13px;
            max-width: 250px;
            z-index: 1000;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transform: translateY(10px);
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
        }

        .tooltip.show {
            opacity: 1;
            transform: translateY(0);
        }

        .tooltip::after {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 0 8px 8px;
            border-style: solid;
            border-color: transparent transparent var(--tooltip-bg);
        }

        .connection-line {
            position: absolute;
            background: rgba(56, 189, 248, 0.4);
            height: 2px;
            z-index: 15;
            transform-origin: left;
            transform: scaleX(0);
            pointer-events: none;
        }

        .connection-line.active {
            transform: scaleX(1);
            box-shadow: 0 0 8px rgba(56, 189, 248, 0.6);
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 235, 59, 0.5); }
            70% { box-shadow: 0 0 0 8px rgba(255, 235, 59, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 235, 59, 0); }
        }

        .scan-section {
            margin-top: 2rem;
            padding: 1.5rem;
            background-color: #f1f5f9;
            border-radius: 0.5rem;
            border: 1px solid #cbd5e1;
        }

        .scan-input-container {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .scan-input {
            flex: 1;
            padding: 0.75rem 1rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.375rem;
            font-size: 1rem;
        }

        .scan-button {
            padding: 0.75rem 1.5rem;
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 0.375rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            position: relative;
            overflow: hidden;
        }

        .scan-button:hover {
            background-color: #2563eb;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .scan-button:active {
            transform: translateY(0);
        }

        .progress-container {
            margin-bottom: 1rem;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .progress-label {
            font-weight: 600;
        }

        .progress-bar {
            height: 0.75rem;
            background-color: #e2e8f0;
            border-radius: 0.375rem;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background-color: #3b82f6;
            border-radius: 0.375rem;
            transition: width 0.5s ease;
        }

        .logs-container {
            background-color: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.375rem;
            padding: 0.75rem;
            margin-bottom: 1rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .log-header {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #475569;
            font-size: 0.875rem;
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 0.375rem;
        }

        .log-item {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
            font-size: 0.75rem;
        }

        .log-time {
            color: #64748b;
        }

        .log-item.success .log-message {
            color: #16a34a;
        }

        .log-item.error .log-message {
            color: #dc2626;
        }

        .log-item.warning .log-message {
            color: #ea580c;
        }

        .notification {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 500;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            display: none;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            z-index: 9999;
            font-size: 0.95rem;
            transform: translateY(20px);
        }

        .notification.show {
            opacity: 1;
            transform: translateY(0);
        }

        .notification.success {
            background-color: #10b981;
            color: white;
            border-left: 5px solid #059669;
        }

        .notification.error {
            background-color: #ef4444;
            color: white;
            border-left: 5px solid #b91c1c;
        }

        .notification.info {
            background-color: #3b82f6;
            color: white;
            border-left: 5px solid #2563eb;
        }

        .notification.warning {
            background-color: #f59e0b;
            color: white;
            border-left: 5px solid #d97706;
        }

        .complete-button {
            margin-top: 1rem;
            padding: 0.75rem 1.5rem;
            background-color: #16a34a;
            color: white;
            border: none;
            border-radius: 0.375rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            position: relative;
            overflow: hidden;
        }

        .complete-button:hover {
            background-color: #15803d;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .complete-button:active {
            transform: translateY(0);
        }

        .complete-button:disabled {
            background-color: #94a3b8;
            cursor: not-allowed;
        }

        .hidden {
            display: none;
        }

        /* Enhanced visual feedback styles */
        .scan-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            animation: flash-animation 0.5s ease-out;
        }

        .success-flash {
            background-color: rgba(16, 185, 129, 0.2);
        }

        .error-flash {
            background-color: rgba(239, 68, 68, 0.2);
        }

        @keyframes flash-animation {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        .verification-icon {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-size: 12px;
            font-weight: bold;
        }

        .verified {
            background-color: rgba(16, 185, 129, 0.9);
            color: white;
        }

        .tooltip-error {
            position: relative;
        }

        .tooltip-error::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 0;
            bottom: -30px;
            background-color: #fee2e2;
            color: #dc2626;
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            white-space: nowrap;
            z-index: 10;
        }

        .duplicate-highlight {
            box-shadow: 0 0 0 4px rgba(245, 158, 11, 0.5) !important;
            position: relative;
            z-index: 50;
        }

        /* Pulse warning animation */
        @keyframes pulse-warning {
            0% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(245, 158, 11, 0); }
            100% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0); }
        }

        .pulse-warning {
            animation: pulse-warning 2s infinite;
        }

        /* Print styles for completion/summary pages */
        @media print {
            body * {
                visibility: hidden;
            }

            #mainContainer, #mainContainer * {
                visibility: visible;
            }

            #mainContainer {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
            }

            button {
                display: none !important;
            }
        }
    </style>
</head>
<body>
    <div class="container" id="mainContainer">
        <div class="header">
            <div class="part-id">5RS011075 <br> 1Master 3Slave <br> 75 mm</div>
            <h1 class="title">RAP - ILI DUCT ASSEMBLY</h1>
        </div>

        <div class="board-to-board-title" id="currentComponentTitle">Ready to Start Scanning</div>

        <div class="circuit-lines"></div>
        <div class="glow"></div>

        <table class="circuit-table" id="circuitTable">
            <tr>
                <td class="component-name">PCB BOARD</td>
                <td class="slave-pcb cell" id="slave-pcb-1" colspan="6" data-tooltip="Assembled RSM SLAVE PCB BL Ver - T">Assembled RSM SLAVE PCB BL Ver - T</td>
                <td class="slave-pcb cell" id="slave-pcb-2" colspan="6" data-tooltip="Assembled RSM SLAVE PCB BL Ver - T">Assembled RSM SLAVE PCB BL Ver - T</td>
                <td class="slave-pcb cell" id="slave-pcb-3" colspan="6" data-tooltip="Assembled RSM SLAVE PCB BL Ver - T">Assembled RSM SLAVE PCB BL Ver - T</td>
                <td class="master-pcb cell" id="master-pcb" colspan="6" data-tooltip="ASSEMBLED RSM MASTER PCB BL Ver">ASSEMBLED RSM MASTER PCB BL Ver</td>
            </tr>
            <tr>
                <td class="component-name">Joining Cable</td>
                <td class="cell empty-cell" colspan="2"></td>
                <td class="cell board-to-board" id="s2s-cable-1" colspan="4" data-tooltip="Slave to Slave PCB (10-12) - 120MM" style="background-color: var(--slave-to-slave-cable); color: var(--text-color-dark);">Slave to Slave PCB <br>(10-12) - 120MM</td>
                <td class="cell empty-cell" colspan="4"></td>
                <td class="cell board-to-board" id="s2s-cable-2" colspan="4" data-tooltip="Slave to Slave PCB (10-12) - 120MM" style="background-color: var(--slave-to-slave-cable); color: var(--text-color-dark);">Slave to Slave PCB <br>(10-12) - 120MM</td>
                <td class="cell empty-cell" colspan="4"></td>
                <td class="cell board-to-board" id="m2s-cable" colspan="4" data-tooltip="Master to Right slave PCB (10-10) - 90MM" style="background-color: var(--master-to-slave-cable); color: var(--text-color-dark);">Master to Right slave PCB <br>(10-10) - 90MM</td>
                <td class="cell empty-cell" colspan="2"></td>
            </tr>
            <tr>
                <td class="component-name">P&C Cable</td>
                <td class="power-cable cell" id="power-cable" colspan="24" data-tooltip="RSM - POWER & COMMUNICATION CABLE ASSY with RMC - BL Ver - (75mm Pitch)">RSM - POWER & COMMUNICATION CABLE ASSY with RMC - BL Ver - (75mm Pitch)</td>
            </tr>
        </table>

        <div id="tooltip" class="tooltip"></div>
        <div id="connectionLine1" class="connection-line"></div>
        <div id="connectionLine2" class="connection-line"></div>

        <div class="scan-section">
            <h2 class="text-xl font-semibold mb-4">Component Verification</h2>
            
            <div class="scan-input-container">
                <input type="text" id="barcodeInput" class="scan-input" placeholder="Scan component barcode..." autofocus>
                <button id="scanButton" class="scan-button">Verify</button>
            </div>
            
            <div class="progress-container">
                <div class="progress-header">
                    <div class="progress-label">Assembly Progress</div>
                    <div class="progress-percentage" id="progressPercentage">0%</div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
            </div>
            
            <div class="logs-container">
                <div class="log-header">Assembly Logs</div>
                <div id="logsContent"></div>
            </div>
            
            <button id="completeButton" class="complete-button hidden" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                    <polyline points="22 4 12 14.01 9 11.01"></polyline>
                </svg>
                Complete Assembly
            </button>
        </div>
    </div>

    <div id="notification" class="notification"></div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Component mapping with item codes for 5RS011075
            const components = {
                "slave_pcb_1": {
                    itemCode: "4RS013097",
                    name: "Slave PCB 1",
                    element: document.querySelector('#slave-pcb-1'),
                    verificationCode: "",
                    scanned: false,
                    index: 1
                },
                "slave_pcb_2": {
                    itemCode: "4RS013097",
                    name: "Slave PCB 2",
                    element: document.querySelector('#slave-pcb-2'),
                    verificationCode: "",
                    scanned: false,
                    index: 2
                },
                "slave_pcb_3": {
                    itemCode: "4RS013097",
                    name: "Slave PCB 3",
                    element: document.querySelector('#slave-pcb-3'),
                    verificationCode: "",
                    scanned: false,
                    index: 3
                },
                "master_pcb": {
                    itemCode: "4RS013114",
                    name: "Master PCB",
                    element: document.querySelector('#master-pcb'),
                    verificationCode: "",
                    scanned: false,
                    index: 4
                },
                "s2s_cable_1": {
                    itemCode: "4RS013147",
                    name: "Slave to Slave Cable 1",
                    element: document.querySelector('#s2s-cable-1'),
                    verificationCode: "",
                    scanned: false,
                    index: 5
                },
                "s2s_cable_2": {
                    itemCode: "4RS013147",
                    name: "Slave to Slave Cable 2",
                    element: document.querySelector('#s2s-cable-2'),
                    verificationCode: "",
                    scanned: false,
                    index: 6
                },
                "m2s_cable": {
                    itemCode: "4RS013121",
                    name: "Master to Right Cable",
                    element: document.querySelector('#m2s-cable'),
                    verificationCode: "",
                    scanned: false,
                    index: 7
                },
                "power_cable": {
                    itemCode: "4RS013145",
                    name: "Power & Communication Cable",
                    element: document.querySelector('#power-cable'),
                    verificationCode: "",
                    scanned: false,
                    index: 8
                }
            };
            
            // Keep track of scanned barcodes to prevent duplicates
            let scannedBarcodes = new Set();
            let inventoryDataLoaded = false;
            let apiConnected = false;
            let offlineMode = false;

            // Get UI elements
            const barcodeInput = document.getElementById('barcodeInput');
            const scanButton = document.getElementById('scanButton');
            const completeButton = document.getElementById('completeButton');
            const progressFill = document.getElementById('progressFill');
            const progressPercentage = document.getElementById('progressPercentage');
            const logsContent = document.getElementById('logsContent');
            
            // Function to show notification
            function showNotification(message, type = 'info') {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.className = 'notification';
                notification.classList.add(type);
                notification.style.display = 'block';
                
                setTimeout(() => {
                    notification.style.opacity = '1';
                }, 10);
                
                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => {
                        notification.style.display = 'none';
                    }, 300);
                }, 3000);
            }
            
            // Function to add log entry
            function addLogEntry(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logItem = document.createElement('div');
                logItem.classList.add('log-item', type);
                logItem.innerHTML = `
                    <span class="log-time">${timestamp}</span>
                    <span class="log-message">${message}</span>
                `;
                logsContent.appendChild(logItem);
                logsContent.scrollTop = logsContent.scrollHeight;
            }

            // Function to update progress bar
            function updateProgress() {
                const totalItems = Object.keys(components).length;
                let scannedCount = Object.values(components).filter(comp => comp.scanned).length;
                
                const progressPercent = Math.round((scannedCount / totalItems) * 100);
                
                progressFill.style.width = `${progressPercent}%`;
                progressPercentage.textContent = `${progressPercent}%`;
            }

            // Update the highlightNextComponent function:
            function highlightNextComponent() {
                // Get the title element
                const titleElement = document.getElementById('currentComponentTitle');
                
                // Clear existing highlights
                Object.values(components).forEach(comp => {
                    if (comp.element) comp.element.classList.remove('next');
                });

                // Find the next component to scan
                const nextComponent = Object.values(components)
                    .sort((a, b) => a.index - b.index)
                    .find(comp => !comp.scanned);

                if (nextComponent && nextComponent.element) {
                    // Highlight the component
                    nextComponent.element.classList.add('next');
                    
                    // Update the title to show what needs to be scanned
                    titleElement.textContent = `Scan Now: ${nextComponent.name}`;
                    titleElement.style.color = '#f97316'; // Orange color for active scanning
                    
                    addLogEntry(`Next scan: ${nextComponent.name}`, 'info');
                } else {
                    // All components scanned
                    titleElement.textContent = 'Assembly Complete';
                    titleElement.style.color = '#16a34a'; // Green for completion
                    
                    completeButton.classList.remove('hidden');
                    completeButton.disabled = false;
                    addLogEntry('All components scanned successfully! Click Complete to finish.', 'success');
                    showNotification('All components verified! Assembly complete.', 'success');
                }
            }

            // Function to fetch verification codes from API
            async function fetchVerificationCodes() {
                try {
                    const API_URL = '/api';
                    let successCount = 0;
                    
                    // Create an array of promises for parallel fetching
                    const fetchPromises = Object.entries(components).map(async ([key, component]) => {
                        try {
                            const response = await fetch(`${API_URL}/item-master/?search=${component.itemCode}`);
                            if (response.ok) {
                                const data = await response.json();
                                if (data && data.length > 0) {
                                    component.verificationCode = data[0].code || "";
                                    successCount++;
                                    return { success: true, key };
                                }
                            }
                            return { success: false, key };
                        } catch (error) {
                            console.error(`Error fetching data for ${key}:`, error);
                            return { success: false, key, error };
                        }
                    });
                    
                    // Wait for all fetch operations to complete
                    const results = await Promise.all(fetchPromises);
                    
                    // Check if we had any successful API calls
                    apiConnected = successCount > 0;
                    
                    if (apiConnected) {
                        addLogEntry(`Connected to API. Loaded ${successCount} verification codes.`, 'success');
                        showNotification('Verification codes loaded successfully', 'success');
                        inventoryDataLoaded = true;
                        return true;
                    } else {
                        throw new Error('Could not fetch verification codes from API');
                    }
                    
                } catch (error) {
                    console.error('Error fetching verification codes:', error);
                    addLogEntry('Failed to connect to API. Switching to offline mode.', 'warning');
                    showNotification('API connection failed. Using offline mode.', 'warning');
                    
                    // Set fallback verification codes for offline mode
                    Object.values(components).forEach(comp => {
                        if (comp.itemCode.includes('4RS013097')) comp.verificationCode = '7';  // Slave PCBs
                        if (comp.itemCode.includes('4RS013114')) comp.verificationCode = 'EA'; // Master PCB
                        if (comp.itemCode.includes('4RS013147')) comp.verificationCode = '5T'; // Slave to Slave
                        if (comp.itemCode.includes('4RS013121')) comp.verificationCode = '6TE'; // Master to Right
                        if (comp.itemCode.includes('4RS013145')) comp.verificationCode = '4R'; // Power Cable
                    });
                    
                    inventoryDataLoaded = true;
                    offlineMode = true;
                    return false;
                }
            }

            // Function to verify a barcode against the expected verification code
            function enhancedVerifyBarcodeFormat(barcode, verificationCode) {
                if (!barcode || !verificationCode) return false;
                
                console.log(`Enhanced verification of barcode: ${barcode} against code: ${verificationCode}`);
                
                try {
                    // Standardize barcode format - remove spaces and convert to uppercase
                    barcode = barcode.trim().toUpperCase();
                    
                    // Ensure barcode is at least 5 characters plus the verification code length
                    const minLength = 4 + verificationCode.length;
                    if (barcode.length < minLength) {
                        console.log(`Barcode too short: ${barcode.length} chars, need at least ${minLength}`);
                        return false;
                    }
                    
                    // Get the relevant section for verification based on code length
                    const relevantSection = barcode.substring(4, 4 + verificationCode.length);
                    const match = relevantSection === verificationCode;
                    
                    console.log(`Verification check: Positions 5-${4 + verificationCode.length} (${relevantSection}) === ${verificationCode}: ${match}`);
                    
                    // Store verification details in logs for traceability
                    if (match) {
                        addLogEntry(`Verified barcode ${barcode} with code ${verificationCode} at position(s) 5${verificationCode.length > 1 ? `-${4 + verificationCode.length}` : ""}`, 'info');
                    }
                    
                    return match;
                } catch (error) {
                    console.error('Error during enhanced barcode verification:', error);
                    addLogEntry(`Verification error: ${error.message}`, 'error');
                    return false;
                }
            }

            // Function to handle barcode scanning
            function handleScan(barcode) {
                if (!inventoryDataLoaded) {
                    showNotification('System not ready. Please wait or reload page.', 'error');
                    addLogEntry('System not ready. Verification codes not loaded.', 'error');
                    return;
                }
                
                // Trim and validate the barcode input
                barcode = barcode.trim().toUpperCase();
                if (!barcode) {
                    showNotification('Please scan a valid barcode', 'error');
                    return;
                }
                
                // Use improved duplicate check
                const duplicateResult = improvedDuplicateCheck(barcode);
                if (duplicateResult.isDuplicate) {
                    // Get the component that already has this barcode
                    let duplicatedComponent = null;
                    if (duplicateResult.duplicateInfo) {
                        duplicatedComponent = components[duplicateResult.duplicateInfo.componentKey];
                        
                        // Provide visual feedback for duplicate
                        if (duplicatedComponent) {
                            provideEnhancedVisualFeedback('duplicate', duplicatedComponent, barcode);
                        }
                    }
                    
                    showNotification(`DUPLICATE BARCODE: ${barcode} has already been scanned!`, 'error');
                    barcodeInput.value = '';
                    return;
                }
                
                // Get the next component to scan
                const nextComponent = Object.values(components)
                    .sort((a, b) => a.index - b.index)
                    .find(comp => !comp.scanned);
                
                if (!nextComponent) {
                    showNotification('All components have been scanned already', 'info');
                    addLogEntry('No more components to scan', 'info');
                    return;
                }
                
                // Use enhanced verification
                if (enhancedVerifyBarcodeFormat(barcode, nextComponent.verificationCode)) {
                    // Mark component as scanned
                    nextComponent.scanned = true;
                    nextComponent.scannedBarcode = barcode;
                    nextComponent.verifiedAt = new Date().toISOString();
                    nextComponent.verifiedBy = 'Current User';
                    
                    // Add to scanned barcodes set
                    scannedBarcodes.add(barcode);
                    
                    // Provide enhanced visual feedback
                    provideEnhancedVisualFeedback('success', nextComponent, barcode);
                    
                    // Log success
                    addLogEntry(`${nextComponent.name} verified successfully: ${barcode}`, 'success');
                    showNotification(`${nextComponent.name} verified successfully!`, 'success');
                    
                    // Update progress
                    updateProgress();
                    
                    // Highlight next component
                    highlightNextComponent();
                } else {
                    // Record verification attempt
                    nextComponent.verificationAttempts = (nextComponent.verificationAttempts || 0) + 1;
                    
                    // Provide enhanced visual feedback for error
                    provideEnhancedVisualFeedback('error', nextComponent, barcode);
                    
                    showNotification(`Invalid barcode for ${nextComponent.name}`, 'error');
                    addLogEntry(`Incorrect barcode for ${nextComponent.name}: ${barcode}`, 'error');
                }
                
                // Clear the input field
                barcodeInput.value = '';
                barcodeInput.focus();
            }

            // Function to complete the assembly
            async function completeAssembly() {
                // Check if all components are scanned
                const allScanned = Object.values(components).every(comp => comp.scanned);
                if (!allScanned) {
                    showNotification('Cannot complete: some components are not scanned', 'error');
                    return false;
                }
                
                if (!assemblyId) {
                    showNotification('Error: No assembly ID found', 'error');
                    completeButton.disabled = false;
                    return false;
                }
                
                try {
                    // Show processing message
                    showNotification('Processing...', 'info');
                    addLogEntry('Completing assembly process...', 'info');
                    
                    // Generate unique barcode number for this assembly
                    const barcodeNumber = generateBarcodeNumber();
                    
                    // Prepare data for submission
                    const assemblyData = {
                        status: 'completed',
                        completed_at: new Date().toISOString(),
                        notes: 'Assembly completed via RSM assembly interface',
                        operator: 'Current User',
                        barcode_number: barcodeNumber,
                        metadata: {
                            scanned_components: Array.from(scannedBarcodes).map((barcode, index) => {
                                // Find which component this barcode is for
                                let componentName = 'Unknown';
                                let itemCode = 'Unknown';
                                for (const [key, component] of Object.entries(components)) {
                                    if (component.scannedBarcode === barcode) {
                                        componentName = component.name;
                                        itemCode = component.itemCode;
                                        break;
                                    }
                                }
                                
                                return {
                                    component_id: `comp_${index}`,
                                    component_name: componentName,
                                    item_code: itemCode,
                                    barcode: barcode,
                                    scan_time: new Date().toISOString()
                                };
                            })
                        }
                    };
                    
                    // Make the API call with proper error handling
                    const response = await fetch(`${API_URL}/assembly-process/${assemblyId}/`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(assemblyData)
                    }).catch(error => {
                        console.error('API call failed:', error);
                        return { ok: false };
                    });
                    
                    // Handle successful API call
                    if (response.ok) {
                        const data = await response.json();
                        
                        // Store completed order data for reference
                        const completedOrderData = {
                            id: assemblyId,
                            status: 'Completed',
                            product: "3Slave 75 mm",
                            item_code: "5RS011075",
                            serial_number: barcodeNumber,
                            completed_at: new Date().toISOString(),
                            components: assemblyData.metadata.scanned_components
                        };
                        
                        // Store in localStorage
                        storeCompletedWorkOrder(completedOrderData);
                        
                        // Move from pending to completed work orders
                        moveWorkOrderToCompleted(assemblyId);
                        
                        // Show detailed completion screen
                        return showDetailedCompletionScreen(assemblyId, barcodeNumber, completedOrderData);
                    }
                    
                    // API call failed - show error recovery options
                    throw new Error('Failed to communicate with server');
                } catch (error) {
                    console.error('Error completing assembly:', error);
                    
                    // Show error recovery screen
                    showErrorScreen(error.message || 'An unexpected error occurred during assembly completion');
                    
                    return false;
                }
            }

            // Function to store completed work order
            function storeCompletedWorkOrder(orderData) {
                try {
                    // Get existing completed orders
                    const completedOrders = JSON.parse(localStorage.getItem('completedWorkOrders') || '[]');
                    
                    // Add this assembly to completed orders
                    completedOrders.push({
                        id: orderData.id,
                        status: 'Completed',
                        product: orderData.product,
                        item_code: orderData.item_code,
                        serial_number: orderData.serial_number,
                        completed_at: orderData.completed_at
                    });
                    
                    // Save back to localStorage
                    localStorage.setItem('completedWorkOrders', JSON.stringify(completedOrders));
                    
                    // Also update the Assembly.jsx completed orders list format
                    const assemblyCompletedOrders = JSON.parse(localStorage.getItem('assemblyCompletedOrders') || '[]');
                    assemblyCompletedOrders.push({
                        id: orderData.id,
                        status: 'Completed',
                        product: orderData.product,
                        item_code: orderData.item_code,
                        serial_number: orderData.serial_number,
                        completed_at: orderData.completed_at
                    });
                    localStorage.setItem('assemblyCompletedOrders', JSON.stringify(assemblyCompletedOrders));
                    
                    addLogEntry(`Assembly ${orderData.id} saved to completed orders`, 'success');
                } catch (error) {
                    console.error('Error storing completed work order:', error);
                    addLogEntry('Failed to store completion status locally', 'warning');
                }
            }

            // Function to move a work order from pending to completed
            function moveWorkOrderToCompleted(assemblyId) {
                try {
                    // Get pending and completed work orders
                    const pendingWorkOrders = JSON.parse(localStorage.getItem('pendingWorkOrders') || '[]');
                    const completedWorkOrders = JSON.parse(localStorage.getItem('assemblyCompletedOrders') || '[]');
                    
                    // Find the work order in pending list
                    const workOrderIndex = pendingWorkOrders.findIndex(order => order.id === assemblyId);
                    
                    if (workOrderIndex !== -1) {
                        // Remove from pending
                        const workOrder = pendingWorkOrders.splice(workOrderIndex, 1)[0];
                        
                        // Mark as completed
                        workOrder.status = 'Completed';
                        workOrder.completed_at = new Date().toISOString();
                        
                        // Add to completed if not already there
                        if (!completedWorkOrders.some(order => order.id === assemblyId)) {
                            completedWorkOrders.push(workOrder);
                        }
                        
                        // Save back to localStorage
                        localStorage.setItem('pendingWorkOrders', JSON.stringify(pendingWorkOrders));
                        localStorage.setItem('assemblyCompletedOrders', JSON.stringify(completedWorkOrders));
                        
                        addLogEntry(`Work order ${assemblyId} moved to completed orders`, 'success');
                    }
                } catch (error) {
                    console.error('Error moving work order:', error);
                    addLogEntry('Error updating work order status', 'error');
                }
            }

            // Function to provide enhanced visual feedback
            function provideEnhancedVisualFeedback(result, component, barcode) {
                const titleElement = document.getElementById('currentComponentTitle');
                
                if (result === 'success') {
                    // Success feedback
                    component.element.classList.remove('next', 'error');
                    component.element.classList.add('success');
                    
                    // Create a visual flash effect
                    const flash = document.createElement('div');
                    flash.className = 'scan-flash success-flash';
                    document.body.appendChild(flash);
                    
                    // Remove after animation completes
                    setTimeout(() => {
                        document.body.removeChild(flash);
                    }, 500);
                    
                    // Play success sound if available
                    const successSound = new Audio('/assets/sounds/success-beep.mp3');
                    successSound.volume = 0.5;
                    successSound.play().catch(e => console.log('Sound not supported or enabled'));
                    
                    // Update the title with check mark
                    titleElement.innerHTML = `<span style="color: #16a34a"></span> ${component.name} verified!`;
                    titleElement.style.color = '#16a34a';
                    
                    // Add success annotation to the component element
                    const checkIcon = document.createElement('div');
                    checkIcon.className = 'verification-icon verified';
                    checkIcon.innerHTML = '';
                    component.element.appendChild(checkIcon);
                } 
                else if (result === 'error') {
                    // Error feedback
                    component.element.classList.remove('success', 'next');
                    component.element.classList.add('error');
                    
                    // Create error flash effect
                    const flash = document.createElement('div');
                    flash.className = 'scan-flash error-flash';
                    document.body.appendChild(flash);
                    
                    // Remove after animation completes
                    setTimeout(() => {
                        document.body.removeChild(flash);
                        component.element.classList.remove('error');
                        component.element.classList.add('next');
                    }, 800);
                    
                    // Play error sound if available
                    const errorSound = new Audio('/assets/sounds/error-beep.mp3');
                    errorSound.volume = 0.5;
                    errorSound.play().catch(e => console.log('Sound not supported or enabled'));
                    
                    // Update the title with error message
                    titleElement.innerHTML = `<span style="color: #dc2626"></span> Invalid barcode for ${component.name}`;
                    titleElement.style.color = '#dc2626';
                    
                    // Add detailed error tooltip to the scan input
                    barcodeInput.dataset.tooltip = `Expected code: ${component.verificationCode} at position ${4 + 1}`;
                    barcodeInput.classList.add('tooltip-error');
                    
                    // Remove tooltip after a few seconds
                    setTimeout(() => {
                        barcodeInput.classList.remove('tooltip-error');
                        delete barcodeInput.dataset.tooltip;
                    }, 3000);
                    
                    // Increment verification attempt counter
                    component.verificationAttempts = (component.verificationAttempts || 0) + 1;
                    
                    // Log the failure details
                    addLogEntry(`Verification failed for ${component.name}: ${barcode} does not match code ${component.verificationCode} at position 5${component.verificationCode.length > 1 ? '+' : ''}`, 'error');
                }
                else if (result === 'duplicate') {
                    // Duplicate feedback - flash the component that already has this barcode
                    const duplicateElement = component.element;
                    duplicateElement.classList.add('duplicate-highlight');
                    
                    // Add pulsing effect
                    duplicateElement.classList.add('pulse-warning');
                    
                    // Remove after animation
                    setTimeout(() => {
                        duplicateElement.classList.remove('duplicate-highlight', 'pulse-warning');
                    }, 2000);
                    
                    // Play duplicate warning sound
                    const warningSound = new Audio('/assets/sounds/warning-beep.mp3');
                    warningSound.volume = 0.5;
                    warningSound.play().catch(e => console.log('Sound not supported or enabled'));
                    
                    // Show notification with which component already used this barcode
                    titleElement.innerHTML = `<span style="color: #f59e0b"></span> Duplicate barcode - already used for ${component.name}`;
                    titleElement.style.color = '#f59e0b';
                }
            }

            // Function to check for duplicate barcodes
            function improvedDuplicateCheck(barcode) {
                // First check the Set of scanned barcodes
                if (scannedBarcodes.has(barcode)) {
                    // Find where this barcode was used
                    let duplicateFound = null;
                    for (const [key, component] of Object.entries(components)) {
                        if (component.scannedBarcode === barcode) {
                            duplicateFound = {
                                componentName: component.name,
                                componentKey: key,
                                scanTime: component.verifiedAt || new Date().toLocaleTimeString()
                            };
                            break;
                        }
                    }
                    
                    // Log the duplicate with details
                    if (duplicateFound) {
                        addLogEntry(`DUPLICATE BARCODE: ${barcode} was already used for ${duplicateFound.componentName} at ${duplicateFound.scanTime}`, 'error');
                    } else {
                        addLogEntry(`DUPLICATE BARCODE: ${barcode} was already scanned`, 'error');
                    }
                    
                    return {
                        isDuplicate: true,
                        duplicateInfo: duplicateFound
                    };
                }
                
                // Also check if any component was already scanned with this barcode
                for (const [key, component] of Object.entries(components)) {
                    if (component.scannedBarcode === barcode) {
                        return {
                            isDuplicate: true,
                            duplicateInfo: {
                                componentName: component.name,
                                componentKey: key,
                                scanTime: component.verifiedAt || new Date().toLocaleTimeString()
                            }
                        };
                    }
                }
                
                return {
                    isDuplicate: false,
                    duplicateInfo: null
                };
            }

            // Function to enhance component tracking
            function enhanceComponentTracking() {
                // Add new properties to component tracking
                Object.values(components).forEach(component => {
                    // Add verification timestamp
                    component.verifiedAt = null;
                    // Add verification operator
                    component.verifiedBy = null;
                    // Add quality check status
                    component.qualityCheckPassed = null;
                    // Add component metadata storage
                    component.metadata = {};
                    // Add verification attempt count
                    component.verificationAttempts = 0;
                    // Add traceability information
                    component.traceabilityInfo = {
                        assemblyId: assemblyId,
                        workstation: 'RSM-5RS011075',
                        timestamp: new Date().toISOString(),
                        workOrder: getWorkOrderFromUrl()
                    };
                });
                
                addLogEntry('Enhanced component tracking initialized', 'info');
            }

            // Get work order ID from URL
            function getWorkOrderFromUrl() {
                const urlParams = new URLSearchParams(window.location.search);
                return urlParams.get('workOrderId') || 'unknown';
            }

            // Initialize enhanced features on page load
            document.addEventListener('DOMContentLoaded', function() {
                // Add the enhanced styles
                addEnhancedStyles();
                
                // Enhance component tracking
                enhanceComponentTracking();
                
                // Continue with existing initialization
                assemblyId = getAssemblyId();
                initializeAssemblyProcess();
            });

            // Set up tooltip functionality
            const cells = document.querySelectorAll('.cell');
            const tooltip = document.getElementById('tooltip');
            
            cells.forEach(cell => {
                cell.addEventListener('mouseenter', function(e) {
                    const tooltipText = this.getAttribute('data-tooltip');
                    if (tooltipText) {
                        tooltip.textContent = tooltipText;
                        tooltip.classList.add('show');
                        
                        const rect = this.getBoundingClientRect();
                        const containerRect = document.querySelector('.container').getBoundingClientRect();
                        
                        tooltip.style.left = rect.left + (rect.width / 2) - (tooltip.offsetWidth / 2) + 'px';
                        tooltip.style.top = rect.bottom + 10 + 'px';
                        
                        if (parseFloat(tooltip.style.left) < containerRect.left) {
                            tooltip.style.left = containerRect.left + 10 + 'px';
                        } else if (parseFloat(tooltip.style.left) + tooltip.offsetWidth > containerRect.right) {
                            tooltip.style.left = containerRect.right - tooltip.offsetWidth - 10 + 'px';
                        }
                    }
                });
                
                cell.addEventListener('mouseleave', function() {
                    tooltip.classList.remove('show');
                });
            });

            // Set up event listeners
            scanButton.addEventListener('click', function() {
                const barcode = barcodeInput.value;
                handleScan(barcode);
                barcodeInput.value = '';
                barcodeInput.focus();
            });
            
            barcodeInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    const barcode = barcodeInput.value;
                    handleScan(barcode);
                    barcodeInput.value = '';
                }
            });
            
            completeButton.addEventListener('click', function() {
                completeAssembly();
            });

            // Initialize the page
            async function initialize() {
                addLogEntry('Initializing assembly process...', 'info');
                
                // Fetch verification codes
                await fetchVerificationCodes();
                
                // Highlight first component
                highlightNextComponent();
            }

            // Start initialization
            initialize();
        });
    </script>
</body>
</html>